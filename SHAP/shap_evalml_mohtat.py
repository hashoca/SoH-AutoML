# -*- coding: utf-8 -*-
"""SHAP_EVALML_MOHTAT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LqVTmoJ4x_59OdNoryi5TB-_ULbi-NSu
"""

!pip install -q numpy pandas scikit-learn shap openpyxl matplotlib

import numpy as np
import pandas as pd
import shap
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
import warnings, time

warnings.filterwarnings("ignore")

EXCEL_PATH = "/content/MOHTAT_dataset_4_PeerJ (1).xlsx"

df = pd.read_excel(EXCEL_PATH)

# Adapt the user's LOCO + SHAP workflow to the uploaded Excel dataset
# and generate downloadable outputs: per-cell SHAP plots, a summary CSV,
# and long-format SHAP data suitable for reproducing the summary plot.
#
# Notes:
# - Uses LinearRegression (as in the user's code)
# - Columns expected: ["Cycle", "EFC", "Temperature", "SoH", "Battery"]
# - Produces:
#     shap_results_summary.csv                -> metrics + mean |SHAP| per feature per test cell
#     shap_long_all_cells.csv                 -> long-format SHAP data for all test cells (for plotting)
#     shap_cell_<CellName>.csv                -> per-cell test rows + SHAP values
#     shap_importance_<CellName>.png          -> per-cell SHAP summary (dot) plot
#     shap_outputs.zip                        -> zipped bundle of all above
#
# Display: The summary DataFrame is shown in an interactive table.
import os, zipfile, io, warnings, time
import numpy as np
import pandas as pd
import shap
import matplotlib.pyplot as plt

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

warnings.filterwarnings("ignore")

EXCEL_PATH = "/content/MOHTAT_dataset_4_PeerJ (1).xlsx"
OUTDIR = "/content/shap_outputs"
os.makedirs(OUTDIR, exist_ok=True)

# --- Load data
df = pd.read_excel(EXCEL_PATH)

# Verify required columns
FEATURES = ["Cycle", "EFC", "Temperature"]
TARGET = "SoH"
CELL_COL = "Battery"

print("Available columns in the DataFrame:")
print(df.columns)

missing = [c for c in [*FEATURES, TARGET, CELL_COL] if c not in df.columns]
if missing:
    raise ValueError(f"Missing required columns: {missing}")

# Drop NaNs
df = df.dropna(subset=[*FEATURES, TARGET, CELL_COL]).copy()

# Collect cells
cells = sorted(df[CELL_COL].unique())

results = []
long_rows = []  # for long-format SHAP data across all cells

for idx, cell in enumerate(cells):
    test_df = df[df[CELL_COL] == cell].copy()
    train_df = df[df[CELL_COL] != cell].copy().reset_index(drop=True) # Reset index for SHAP explainer
    X_train = train_df[FEATURES]
    y_train = train_df[TARGET]
    X_test = test_df[FEATURES]
    y_test = test_df[TARGET]

    # Train model
    model = LinearRegression()
    t0 = time.time()
    model.fit(X_train, y_train)
    train_time = time.time() - t0

    # Predict
    y_pred = model.predict(X_test)
    rmse = float(np.sqrt(mean_squared_error(y_test, y_pred)))
    mae = float(mean_absolute_error(y_test, y_pred))
    r2 = float(r2_score(y_test, y_pred))

    # SHAP
    explainer = shap.Explainer(model, X_train)
    shap_values = explainer(X_test)  # Explanation object

    # SHAP summary plot (dot)
    plt.figure()
    shap.summary_plot(shap_values, X_test, show=False)
    plt.title(f"Feature Importance (Cell: {cell})")
    plt.tight_layout()
    fig_path = os.path.join(OUTDIR, f"shap_importance_{cell}.png")
    plt.savefig(fig_path, dpi=160, bbox_inches="tight")
    plt.close()

    # Mean absolute SHAP importance per feature
    mean_importance = np.abs(shap_values.values).mean(axis=0)
    feature_ranking = dict(zip(FEATURES, mean_importance))

    # Save per-cell SHAP dataset (wide) for reproducibility
    per_cell = X_test.reset_index(drop=True).copy()
    for j, f in enumerate(FEATURES):
        per_cell[f"SHAP_{f}"] = shap_values.values[:, j]
        per_cell[f"ABS_SHAP_{f}"] = np.abs(shap_values.values[:, j])
    per_cell[TARGET] = y_test.reset_index(drop=True)
    per_cell_path = os.path.join(OUTDIR, f"shap_cell_{cell}.csv")
    per_cell.to_csv(per_cell_path, index=False)

    # Also accumulate long-format rows for the "last graph" (summary plot) dataset
    for row_idx in range(len(X_test)):
        for j, f in enumerate(FEATURES):
            long_rows.append({
                "Battery": cell,
                "RowIndex": row_idx,
                "Feature": f,
                "FeatureValue": float(X_test.iloc[row_idx, j]),
                "SHAPValue": float(shap_values.values[row_idx, j]),
                "ABS_SHAP": float(abs(shap_values.values[row_idx, j])),
                TARGET: float(y_test.iloc[row_idx])
            })

    # Append metrics row
    result_row = {
        "Test_Cell": cell,
        "RMSE": round(rmse, 5),
        "MAE": round(mae, 5),
        "R2": round(r2, 5),
        "Train_Time_sec": round(train_time, 4)
    }
    for f in FEATURES:
        result_row[f"Mean_|SHAP|_{f}"] = round(feature_ranking[f], 6)
    results.append(result_row)

# Save summary CSV
df_results = pd.DataFrame(results)
summary_csv = os.path.join(OUTDIR, "shap_results_summary.csv")
df_results.to_csv(summary_csv, index=False)

# Save long-format SHAP data (all cells)
df_long = pd.DataFrame(long_rows)
long_csv = os.path.join(OUTDIR, "shap_long_all_cells.csv")
df_long.to_csv(long_csv, index=False)

# Zip everything for easy download
zip_path = "/content/shap_outputs.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
    for root, _, files in os.walk(OUTDIR):
        for fn in files:
            zf.write(os.path.join(root, fn), arcname=os.path.join(os.path.basename(OUTDIR), fn))

# Display the summary results table to user
# display_dataframe_to_user("LOCO + SHAP Summary (LinearRegression)", df_results) # This function is not available, using display() instead
display(df_results)


print("Outputs generated:")
print(" Summary table: ", summary_csv)
print(" Long-format SHAP data (for summary plot): ", long_csv)
print(" All artifacts (plots + per-cell CSVs + summaries): ", zip_path)